\documentclass[11pt]{article}

\title{Software Reliability -- Coursework 2 \\ Software Reliability Tools}
\author{Jack Bracewell, Milan Misak, Craig Ellis}
\date{}

\usepackage{float}
\usepackage[margin=1.5in]{geometry}

\begin{document}

\maketitle

\section{SSA Renaming}

This task was reasonably straighforward, though we did run into a few small issues when we implemented later
tasks, and we had to return and handle some edge cases in the \verb|SSAVisitor| class. These were mainly to do
with variables we introduced in predication, and the `free' variables we introduced when handling \verb|havoc|
statements. \\

In terms of implementation, we simply kept a record (using a \verb|Map|) of the current number of assignments to
each variable, starting with 0 when the variable is declared. We then just needed to append the character `\$',
and this recorded number every time we encountered a reference to the variable. Upon reaching an assignment
statement, we first handled the right-hand side of the assignment \emph{before} incrementing assignment count -
to account for cases where the assignment may reference the variable itself (eg. \verb|x = x + 1|). \\

The problems we encountered with the variables we had introduced were solved with a check for the character `\$',
which we would use in our variables.

\section{Loop Removal}
Is this part of predicated execution
\section{Predicated execution}
The workhorse of our implementation of Predicated Execution is our scope stack. This scope stack initially
has the Global predicate pushed onto it. Then, each time a conditional is entered, the predicate for its
satifaction is pushed onto the stack, similarly when the conditional body is left, this Predicate is
popped off the stack.\\

TODO: Why do we actually have the global predicate on the stack now?

Every assignment statement (Including those of new predicates), is predicated using the ternary operator
with the Latest version of the global predicate, in conjunction with the conditional predicate on the
top of our scope stack. If this check fails, then the assignment will return the original variable value
(equivalent to a no-op), otherwise - the assignment will succeed. \\

TODO: Talk about \verb|havoc()| and \verb|assume()|

\section{Bounded Model Checking}
\section{Verification mode}
\section{Houdini}

For our implementation of Houdini we decided to translate each of the loops in the program, into its own
program which we then run our the main functionality of the tool on. This required creating a new AST
program, which consisted of the same declist (program arguments), along with the same intial list of
variable declarations. No other in formation from the original program needs to be copied, because our
candidate loop invariants are inductive, we don't care about the state of the program before the loop
is reached. We also don't care about any assertions that may occur after the execution of this loop.

\section{Candidate Invariant Generation}
\section{Competition Mode}

\end{document}
