\documentclass[11pt]{article}

\title{Software Reliability -- Coursework 2 \\ Software Reliability Tools}
\author{Jack Bracewell, Milan Misak, Craig Ellis}
\date{}

\usepackage{float}
\usepackage{tikz}
\usepackage[margin=1.5in]{geometry}
\usepackage[ruled, linesnumbered]{algorithm2e}

\begin{document}

\maketitle

\section{SMT Formula Generation (maybe not this section?)}
\section{SSA Renaming}

This task was reasonably straightforward, though we did run into a few small issues when we implemented later
tasks, and we had to return and handle some edge cases in the \verb|SSAVisitor| class. These were mainly to do
with variables we introduced in predication, and the `free' variables we introduced when handling \verb|havoc|
statements. \\

In terms of implementation, we simply kept a record (using a \verb|Map|) of the current number of assignments to
each variable, starting with 0 when the variable is declared. We then just needed to append the character `\$',
and this recorded number every time we encountered a reference to the variable. Upon reaching an assignment
statement, we first handled the right-hand side of the assignment \emph{before} incrementing assignment count -
to account for cases where the assignment may reference the variable itself (eg. \verb|x = x + 1|). \\

The problems we encountered with the variables we had introduced were solved with a check for the character `\$',
which we would use in our variables.

\section{Loop Removal}
Is this part of predicated execution
\section{Predicated execution}
The workhorse of our implementation of Predicated Execution is our scope stack. This scope stack initially
has the Global predicate pushed onto it. Then, each time a conditional is entered, the predicate for its
satisfaction is pushed onto the stack, similarly when the conditional body is left, this Predicate is
popped off the stack.\\

TODO: Why do we actually have the global predicate on the stack now?

Every assignment statement (Including those of new predicates), is predicated using the ternary operator
with the Latest version of the global predicate, in conjunction with the conditional predicate on the
top of our scope stack. If this check fails, then the assignment will return the original variable value
(equivalent to a no-op), otherwise - the assignment will succeed. \\

TODO: Talk about \verb|havoc()| and \verb|assume()|

\section{Bounded Model Checking}
Did we do anything extra than the notes?
\section{Verification mode}
Did we do anything extra than the notes?
\section{Houdini}

For Houdini we decided to compute invariant fixed points for all the loops in the program simultaneously.
We made this decision because only top-level sequential loop invariants would not \emph{need} to be proved
this way. Wheras any loop nested inside another loop would have co-dependent invariants with its parent. \\

If we take look at Figure 1 for example. We have five loops, with loops \verb|1|, \verb|2| and \verb|5| occuring
sequentially on the top level, and loops \verb|3| and \verb|4| nested inside loop \verb|2|. We can compute
invariants for loop \verb|1| without any of the other loops, because its invariants are not dependent on any
others. But the invariants for loop \verb|2|, \verb|3| and \verb|4| need to be computed simultaneously, because
they are part of a cycle in the invariant dependency graph. We could then compute invariants for loop \verb|5|
in isolation. \\



\begin{figure}[H]
\begin{center}
  \begin{minipage}[b]{.4\textwidth}
    \begin{algorithm}[H]
    main() {

    int i;
    int j;
    i = 0;
    j = 0;

    \While{i \textless 1 \tcp*{loop 1}} {
        i = 1;
    }

    \While{i \textless 5 \tcp*{loop 2}}
    {
      \While{j \textless 1 \tcp*{loop 3}} {
            j = j + 1;
        }
        j = j;

        \While{j \textless 0 \tcp*{loop 4}} {
            i = i + 1;
            j = j - 1;
        }
    }

    \While{i \textless 0 \tcp*{loop 5}} {
        i = i - 1;
    }

    assert(i == 0);
    }
    \caption{Example multi-loop program}
    \end{algorithm}
  \end{minipage}
  \quad \quad \quad \quad \quad \quad \quad \quad
  \begin{minipage}[H]{.3\textwidth}
    \input{./graph.tex}
  \end{minipage}
\end{center}
\caption{An example simpleC program containing a number of while loops, and the corresponding invariant dependency graph}
\end{figure}

We decided to simply compute the invariants of all loops simultaneously, even though this would mean spending more
time in the sat solver (5 sets of loop invariants to compute, and worse case exponential complexity of SAT solver).
In practice, for small simpleC programs the overhead required to compute the dependency graph, and run through multiple
fixed point computations would take longer than the time saved in the SAT solver, especially since exponential is worst
case complexity, and will be much lower in practice.

\section{Invgen Mode}
After knowing which invariants failed, we then iteratively ran the verifier, removing failed invariants each time
until we reached a fixed point.

\subsection{Nested Loops}

When proving invariants of nested loops, we must verify the outer loop simultaneously with any interior loops. This
is because the invariants of each loop are dependent on each other. (This gon be reel complicated)

\section{Candidate Invariant Generation}
Not done it yet.
\section{Competition Mode}
Not done it yet.

\end{document}
