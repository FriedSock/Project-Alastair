\documentclass[11pt]{article}

\title{Software Reliability -- Coursework 2 \\ Software Reliability Tools}
\author{Jack Bracewell, Milan Misak, Craig Ellis}
\date{}

\usepackage{float}
\usepackage[margin=1.5in]{geometry}

\begin{document}

\maketitle

\section{SMT Formula Generation (maybe not this section?)}

\section{SSA Renaming}

This task was reasonably straightforward, though we did run into a few small issues when we implemented later tasks, and we had to return and handle some edge cases in the \verb|SSAVisitor| class. These were mainly to do with variables we introduced in predication, and the `free' variables we introduced when handling \verb|havoc| statements.

In terms of implementation, we simply kept a record (using a \verb|Map|) of the current number of assignments to each variable, starting with 0 when the variable is declared. We then just needed to append the character `\$', and this recorded number every time we encountered a reference to the variable. Upon reaching an assignment statement, we first handled the right-hand side of the assignment \emph{before} incrementing assignment count - to account for cases where the assignment may reference the variable itself (eg. \verb|x = x + 1|).

The problems we encountered with the variables we had introduced were solved with a check for the character `\$', which we would use in our variables.

\section{Predication}

The workhorse in our implementation of Predicated Execution is our scope stack. This stack initially contains the Global predicate, then each time a conditional is entered, the predicate for its satisfaction is pushed onto the stack. Similarly, when the conditional body is left this Predicate is popped off the stack.

Pushing the Global Predicate to the stack initially allows us to simply \verb|peek| at the top element when predicating a statement.

Every assignment statement (including those of new predicates), is predicated using the ternary operator with both the latest version of the global predicate and the conditional predicate on the top of our scope stack. If the predicate fails, then the assignment will return the original variable value (equivalent to a no-op), otherwise the assignment will succeed.

As previously stated, when we predicate a statement we use both the global predicate and the predicate on top of the stack - even though the topmost predicate should include the global predicate anyway. This is to take into account any \verb|assume| statements we encounter inside a conditional branch. The \verb|assume| will change the global predicate, and we decided that it was much less complicated to simply include both predicates instead of altering everything in the stack. As a consequence of this, when we are not in a conditional branch the predicate is duplicated (eg. \verb|(G$0 && G$0)|), though this does not affect the outcome.

TODO: Talk about \verb|havoc()| and \verb|assume()|

\section{Bounded Model Checking}

Did we do anything extra than the notes?

\section{Verification Mode}

Did we do anything extra than the notes?

\section{Houdini Mode}

For our implementation of Houdini we decided to translate each of the loops in the program, into its own program which we then run the loop verification functionality of the tool on. This involved an inserting an \verb|assert(0)| after the loop had finished (because we don't care about what happens in the program after this loop). We did, however, need to care about all statements before the loop starts, so we can know if the loop invariants hold the first time the loop head is reached.

After the verifier had been run on a while loop for the first time, we need to check which of the candidate invariants failed. This required renaming the \verb|assert| statements in our SMT formula that corresponded to each candidate invariant.

TODO: Give an example

\subsection{Nested Loops}

When proving invariants of nested loops, we must verify the outer loop simultaneously with any interior loops. This is because the invariants of each loop are dependent on each other. (This gon be reel complicated)

\section{Invgen Mode}

After knowing which invariants failed, we then iteratively ran the verifier, removing failed invariants each time until we reached a fixed point.

\section{Competition Mode}

Not done it yet.

\end{document}
